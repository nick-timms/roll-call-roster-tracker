// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://ktwcyzsxzivlibsaschj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt0d2N5enN4eml2bGlic2FzY2hqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDcyMzY4NTAsImV4cCI6MjA2MjgxMjg1MH0.upfigrj13S8wW_C-nIxYbrzBrOyMitEN-wcDVCzJ7zY";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Create Supabase client with improved configuration
export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      detectSessionInUrl: true,
      storage: typeof window !== 'undefined' ? localStorage : undefined
    },
    global: {
      headers: {
        'X-Client-Info': 'lovable-app',
      },
    },
    // Remove debug property as it's not in the type definition
  }
);

// Simple function to validate if user has an active session
export const hasValidSession = async (): Promise<boolean> => {
  try {
    console.log("Checking for valid session...");
    const { data, error } = await supabase.auth.getSession();
    
    if (error) {
      console.error("Session validation error:", error);
      return false;
    }
    
    const isValid = !!data.session?.user && !!data.session?.access_token;
    console.log("Session validation result:", isValid ? "Valid session" : "No valid session");
    
    // If we have a session, log some details about it
    if (isValid && data.session) {
      const expiresAt = data.session.expires_at 
        ? new Date(data.session.expires_at * 1000).toISOString() 
        : 'unknown';
        
      console.log("Session details:", {
        user_id: data.session.user.id,
        email: data.session.user.email,
        expires_at: expiresAt,
        current_time: new Date().toISOString()
      });
      
      // Check token validity window - if about to expire, trigger refresh
      const now = Math.floor(Date.now() / 1000);
      if (data.session.expires_at && (data.session.expires_at - now < 300)) { // Less than 5 minutes remaining
        console.log("Token expiring soon, refreshing...");
        await refreshSession();
      }
    }
    
    return isValid;
  } catch (e) {
    console.error("Failed to validate session:", e);
    return false;
  }
};

// Enhanced logging of authentication state
export const logAuthState = async () => {
  try {
    console.log("Checking authentication state...");
    const { data: { session } } = await supabase.auth.getSession();
    
    if (session) {
      const expiresAt = session.expires_at 
        ? new Date(session.expires_at * 1000).toISOString() 
        : 'unknown';
      
      console.log("Auth state:", {
        isAuthenticated: true,
        user: {
          id: session.user.id,
          email: session.user.email,
          has_access_token: !!session.access_token
        },
        expires_at: expiresAt,
        current_time: new Date().toISOString()
      });
      
      // Check token in localStorage
      if (typeof localStorage !== 'undefined') {
        try {
          const localSession = localStorage.getItem('sb-ktwcyzsxzivlibsaschj-auth-token'); // Use actual project ref
          console.log("LocalStorage session exists:", !!localSession);
          
          if (localSession) {
            try {
              const parsed = JSON.parse(localSession);
              console.log("LocalStorage token expiry:", parsed?.expires_at ? 
                new Date(parsed.expires_at * 1000).toISOString() : 'unknown');
            } catch (parseError) {
              console.warn("Could not parse localStorage session:", parseError);
            }
          }
        } catch (e) {
          console.warn("Error checking localStorage:", e);
        }
      }
      
      return true;
    } else {
      console.log("Auth state: No active session");
      return false;
    }
  } catch (e) {
    console.error("Failed to log auth state:", e);
    return false;
  }
};

// Function to get current user - useful for debugging
export const getCurrentUser = async () => {
  try {
    const { data: { user }, error } = await supabase.auth.getUser();
    if (error) {
      console.error("Error getting current user:", error);
      return null;
    }
    return user;
  } catch (e) {
    console.error("Exception getting current user:", e);
    return null;
  }
};

// Function to manually refresh the session token
export const refreshSession = async () => {
  try {
    console.log("Attempting to refresh session...");
    const { data, error } = await supabase.auth.refreshSession();
    
    if (error) {
      console.error("Error refreshing session:", error);
      return false;
    }
    
    console.log("Session refresh successful:", !!data.session);
    
    // Log updated token expiry
    if (data.session?.expires_at) {
      const expiresAt = new Date(data.session.expires_at * 1000).toISOString();
      console.log("New token expires at:", expiresAt);
    }
    
    return !!data.session;
  } catch (e) {
    console.error("Exception refreshing session:", e);
    return false;
  }
};

// Test database connectivity
export const testDatabaseConnection = async () => {
  try {
    console.log("Testing database connection...");
    const { data, error } = await supabase.from('gyms').select('count').limit(1);
    
    if (error) {
      console.error("Database connection test failed:", error);
      if (error.code === 'PGRST301' || error.message.includes('permission denied') || error.message.includes('JWT')) {
        console.log("Possible authentication issue - trying session refresh before retry");
        await refreshSession();
        // Retry after token refresh
        const { data: retryData, error: retryError } = await supabase.from('gyms').select('count').limit(1);
        if (retryError) {
          console.error("Database connection retry failed after token refresh:", retryError);
          return false;
        }
        console.log("Database connection successful after token refresh:", retryData);
        return true;
      }
      return false;
    }
    
    console.log("Database connection successful:", data);
    return true;
  } catch (e) {
    console.error("Exception testing database connection:", e);
    return false;
  }
};

// Enhanced database diagnostics with detailed error reporting
export const diagnoseDatabaseConnection = async (): Promise<{
  success: boolean;
  authStatus: 'valid' | 'expired' | 'missing' | 'invalid';
  networkStatus: 'connected' | 'disconnected';
  permissions: 'granted' | 'denied' | 'unknown';
  message: string;
}> => {
  try {
    // First check if we have a valid session
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session) {
      console.log("Diagnostics: No valid session found");
      return {
        success: false,
        authStatus: 'missing',
        networkStatus: 'connected', // We made it here, so network is up
        permissions: 'unknown',
        message: 'No active authentication session found'
      };
    }
    
    // Check token expiry
    const now = Math.floor(Date.now() / 1000);
    const tokenExpired = session.expires_at && (session.expires_at < now);
    
    if (tokenExpired) {
      console.log("Diagnostics: Token expired, refreshing...");
      const refreshed = await refreshSession();
      if (!refreshed) {
        return {
          success: false,
          authStatus: 'expired',
          networkStatus: 'connected',
          permissions: 'unknown',
          message: 'Authentication token expired and refresh failed'
        };
      }
    }
    
    // Test a simple query
    const { data, error } = await supabase.from('gyms').select('count').limit(1);
    
    if (error) {
      console.error("Diagnostics: Query failed:", error);
      
      // Check if it's a permission issue
      if (error.code === 'PGRST301' || error.message.includes('permission denied')) {
        return {
          success: false,
          authStatus: 'valid', // We have a token, but permissions are wrong
          networkStatus: 'connected',
          permissions: 'denied',
          message: `Permission denied: ${error.message}`
        };
      }
      
      // Check if it's a JWT issue
      if (error.message.includes('JWT')) {
        return {
          success: false,
          authStatus: 'invalid',
          networkStatus: 'connected',
          permissions: 'unknown',
          message: `Invalid authentication token: ${error.message}`
        };
      }
      
      // Otherwise assume it's a network/connection issue
      return {
        success: false,
        authStatus: 'valid',
        networkStatus: 'disconnected',
        permissions: 'unknown',
        message: `Database connection error: ${error.message}`
      };
    }
    
    // Success case
    return {
      success: true,
      authStatus: 'valid',
      networkStatus: 'connected',
      permissions: 'granted',
      message: 'Database connection successful'
    };
  } catch (e: any) {
    console.error("Diagnostics: Unexpected error during diagnosis:", e);
    return {
      success: false,
      authStatus: 'invalid', // Changed from "unknown" to "invalid"
      networkStatus: 'disconnected',
      permissions: 'unknown',
      message: `Unexpected error: ${e.message || 'Unknown error'}`
    };
  }
};
