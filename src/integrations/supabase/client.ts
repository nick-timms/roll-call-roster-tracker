
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://ktwcyzsxzivlibsaschj.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imt0d2N5enN4eml2bGlic2FzY2hqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDcyMzY4NTAsImV4cCI6MjA2MjgxMjg1MH0.upfigrj13S8wW_C-nIxYbrzBrOyMitEN-wcDVCzJ7zY";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(
  SUPABASE_URL, 
  SUPABASE_PUBLISHABLE_KEY,
  {
    auth: {
      autoRefreshToken: true,
      persistSession: true,
      storage: localStorage,
      detectSessionInUrl: true
    },
    global: {
      headers: {
        'apikey': SUPABASE_PUBLISHABLE_KEY,
        'Content-Type': 'application/json'
      },
      fetch: (url, options = {}) => {
        const fetchOptions = {
          ...options,
          headers: {
            ...((options as any)?.headers || {}),
            'apikey': SUPABASE_PUBLISHABLE_KEY,
            'Content-Type': 'application/json'
          }
        };
        
        console.log('Supabase fetch URL:', url);
        console.log('Fetch options:', JSON.stringify({
          ...fetchOptions,
          headers: {
            ...((fetchOptions as any).headers || {}),
            Authorization: (fetchOptions as any).headers?.Authorization ? 'Bearer token present' : 'No auth token'
          }
        }, null, 2));
        
        // Wrap fetch with retry logic for network issues
        let retries = 0;
        const maxRetries = 3;
        const baseDelay = 500;
        
        const executeFetch = async (): Promise<Response> => {
          try {
            const response = await fetch(url, fetchOptions);
            
            console.log(`Response status for ${url}: ${response.status}`);
            // Clone response for logging but still return original
            if (response.status >= 400) {
              try {
                const errorText = await response.clone().text();
                console.error(`Error response for ${url}:`, response.statusText, errorText);
              } catch (error) {
                console.error(`Error capturing error details for ${url}:`, error);
              }
            }
            return response;
          } catch (error) {
            console.error(`Fetch error for ${url}:`, error);
            if (retries < maxRetries) {
              retries++;
              const delay = baseDelay * Math.pow(2, retries - 1); // Exponential backoff
              console.log(`Retrying in ${delay}ms (attempt ${retries} of ${maxRetries})...`);
              await new Promise(resolve => setTimeout(resolve, delay));
              return executeFetch();
            }
            throw error;
          }
        };
        
        return executeFetch();
      }
    }
  }
);

// Helper to check if we have a valid session
export const hasValidSession = async (): Promise<boolean> => {
  try {
    const { data, error } = await supabase.auth.getSession();
    if (error) {
      console.error("Session validation error:", error);
      return false;
    }
    return !!data.session;
  } catch (e) {
    console.error("Failed to validate session:", e);
    return false;
  }
};

// Helper to log authentication state for debugging
export const logAuthState = async () => {
  try {
    const { data: { session } } = await supabase.auth.getSession();
    const sessionInfo = session ? {
      user: {
        id: session.user.id,
        email: session.user.email,
        has_token: !!session.access_token
      },
      expires_at: new Date(session.expires_at! * 1000).toISOString()
    } : "No active session";
    
    console.log("Auth state:", sessionInfo);
    return !!session;
  } catch (e) {
    console.error("Failed to log auth state:", e);
    return false;
  }
};
